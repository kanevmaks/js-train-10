// Завдання: 1

/**
 * Функція `customAssign` об'єднує властивості декількох об'єктів за допомогою методу `assign`.
 * Крім того, вона перетворює значення числових властивостей на рядки і замінює пробіли на підкреслення.
 * objects - Об'єкти, властивості яких будуть об'єднані.
 * Повертаємо - Новий об'єкт з об'єднаними властивостями.
 */
function findElementGreaterThan(arr, num) {
  if (Array.isArray(arr)) {
    let found = arr.find((element) => element > num);
    return found;
  } else {
    return undefined;
  }
  // Перевіряємо, чи вхідний параметр є масивом, якщо ні повертаємо undefined
  // повертаємо undefined
  // Використовуємо метод find для пошуку першого елементу, який є більшим за задане число num.
  // Перевіряємо чи є елемент який задовільняє умову
  //Якщо так повертаємо елемент
  // Якщо ні повертаємо рядок Числа яке задовільняе умову не знайдено
}

// Приклад використання функції customAssign
console.log("Завдання: 1 ==============================");

console.log(customAssign({ a: 1, b: 2 }, { c: 3, d: 4 }, { e: 5, f: 6 }));
//Виведе: { a: '1', b: '2', c: '3', d: '4', e: '5', f: '6' }

// Завдання: 2

/**
 * Функція `customEntries` повертає масив, що містить усі властивості об'єкта та їх значення у вигляді масивів.
 * Використовується метод `entries`.
 * Об'єкт, властивості якого потрібно отримати.
 * Повертаємо - Масив, що містить усі властивості та їх значення.
 */
function findIndexByProperty(arr, name) {
  if (Array.isArray(arr)) {
    const foundIndex = arr.findIndex((element) => element.name === name);
    if (foundIndex == -1) {
      return undefined;
    } else {
      return foundIndex;
    }
  } else {
    return undefined;
  }
  // Перевіряємо, чи вхідний параметр є масивом, якщо ні повертаємо -1
  // Використовуємо метод findIndex для пошуку індексу об'єкта, властивість 'name' якого співпадає з заданим іменем.
  // Повертаємо знайдений індекс або -1, якщо об'єкт не знайдено.
}

// Приклад використання функції customEntries
console.log("Завдання: 2 ==============================");

console.log(
  customEntries({
    name: "John",
    age: 30,
    occupation: "Developer",
  })
); //Виведе:[ [ 'name', 'John' ], [ 'age', 30 ], [ 'occupation', 'Developer' ] ]

// Завдання: 3

/**
 * Функція `customObjectFromEntries` створює об'єкт з масиву записів, додатково обробляючи значення властивостей.
 * Значення числових властивостей перетворюються на рядки та замінюються пробіли на підкреслення.
 * Масив записів, кожен запис представлений як [key, value].
 * Повертаємо - Об'єкт, створений з записів з обробленими значеннями.
 */
function findLastEvenNumber(arr) {
  if (Array.isArray(arr)) {
    const isEven = (element) => element % 2 === 0;
    return arr[arr.findLastIndex(isEven)];
  } else {
    return undefined;
  }
  // Перевіряємо, чи вхідний параметр є масивом, якщо ні повертаємо 'Вхідний параметр має бути масивом'
  // За допомогою метода findLast знаходимо останнє парне число в масиві.
  // Повертаємо знайдене число або 'Парних чисел не знайдено', якщо таке число не знайдено.
}

console.log("Завдання: 3 ==============================");

// Виведення результату в консоль
console.log(
  customObjectFromEntries([
    ["a", 1],
    [43, "Hello"],
    ["c", 3.14],
    ["d", "World"],
    [56, 42],
  ])
); //Виведе:{ '43': '43', '56': '56', a: 1, c: 3.14, d: 'World' }

// Завдання: 4

/**
 * Функція checkProperty приймає об'єкт та ключ. Функція перевіряє, чи має об'єкт вказану властивість.
 * Використовується метод hasOwnProperty() для реалізації.
 * obj - вхідний об'єкт, prop - ключ властивості.
 * Повертає - boolean - true, якщо об'єкт має властивість, інакше false.
 */
function getSubArrayAndConvertToString(arr, startIdx) {
  if (!Array.isArray(arr)) {
    return "Not an array";
  }

  let slicedArr = arr.slice(startIdx);
  return slicedArr.join(" ");
  // Перевіряємо, чи вхідний параметр є масивом, якщо ні повертаємо 'Вхідний параметр має бути масивом'
  // За допомогою методу slice() отримуємо підмасив від заданого індексу до кінця масиву.
  // За допомогою методу join() конвертуємо підмасив в рядок.
  // Повертаємо рядок.
}
console.log("Завдання: 4 ==============================");
console.log(checkProperty({ a: 1, b: 2, c: 3 }, "b")); // Виведе true

// Завдання: 5

/**
 * Функція extendAndFreezeObject приймає два об'єкти, розширює перший властивостями другого і "заморожує" отриманий об'єкт, запобігаючи подальшим змінам.
 * Використовується методи Object.assign() та Object.freeze() для реалізації.
 * obj1, obj2 - вхідні об'єкти.
 * Повертає - obj1 - об'єкт, що було розширено властивостями obj2 і "заморожено".
 */
function getArrayKeys(arr) {
  if (!Array.isArray(arr)) {
    return "Not an array";
  }

  return Array.from(arr.keys());
  // Перевіряємо, чи вхідний параметр є масивом, якщо ні повертаємо 'Вхідний параметр має бути масивом'
  // За допомогою методу keys() отримуємо об'єкт ітератора, який містить ключі масиву.
  // Конвертуємо ітератор в масив за допомогою методу from.
  // Повертаємо масив ключів.
}
console.log("Завдання: 5 ==============================");
console.log(extendAndFreezeObject({ a: 1, b: 2 }, { c: 3, d: 4 })); // Виведе {a: 1, b: 2, c: 3, d: 4}

// Завдання: 6

/**
 * Функція keysAndValues приймає об'єкт, виводить в консоль його ключі та значення, і повертає масив з масивами ключів та значень.
 * Використовуються методи Object.keys(), Object.values() та Object.entries() для реалізації.
 * obj - вхідний об'єкт.
 * Повертає - array - масив, що складається з масиву ключів та масиву значень.
 */
function getPositiveArrayValues(arr) {
  if (!Array.isArray(arr)) {
    return "Not an array";
  }

  return Array.from(arr.values()).filter((element) => element > 0);
  // Перевіряємо, чи вхідний параметр є масивом, якщо ні повертаємо 'Вхідний параметр має бути масивом'
  // За допомогою методу values() отримуємо об'єкт ітератора, який містить значення масиву.
  // Конвертуємо ітератор в масив.
  // За допомогою методу filter() отримуємо масив лише з додатніми значеннями.
  // Повертаємо масив додатніх значень.
}
console.log("Завдання: 6 ==============================");
console.log(keysAndValues({ a: 1, b: 2, c: 3, d: 4 })); // Виведе [['a', 'b', 'c', 'd'], [1, 2, 3, 4]]

// Завдання: 7

/**
 * Функція filterObjectsByKey приймає масив об'єктів та ім'я ключа.
 * Функція повертає новий масив об'єктів, в яких існує вказаний ключ.
 * Використовується метод hasOwnProperty для перевірки наявності ключа в об'єкті.
 * arr - вхідний масив об'єктів.
 * key - ключ, який потрібно знайти.
 * Повертає - новий масив об'єктів, в яких існує вказаний ключ.
 */
function removeAndDouble(arr, startIdx) {
  if (!Array.isArray(arr)) {
    return "Not an array";
  }

  let fromIndex = 0;
  let toIndex = startIdx;

  return arr
    .splice(fromIndex, toIndex)
    .map((element) => (element = element * 2));
  // Перевіряємо, чи вхідний параметр є масивом, якщо ні повертаємо 'Вхідний параметр має бути масивом'
  // За допомогою методу splice() видаляємо елементи масиву починаючи з заданого індексу.
  // За допомогою методу map() подвоюємо кожен елемент масиву.
  // Повертаємо масив подвоєних елементів.
}
console.log("Завдання: 7 ==============================");
console.log(
  filterObjectsByKey([{ a: 1, b: 2 }, { a: 3, b: 4 }, { a: 5 }], "b")
); // Виведе [{a: 1, b: 2}, {a: 3, b: 4}]

// Завдання: 8

/**
 * Функція checkAndPreventExtensions приймає об'єкт.
 * Функція перевіряє, чи можливо додати нові властивості до об'єкта,
 * якщо так - вона запобігає подальшому додаванню властивостей до об'єкта.
 * Використовуються методи preventExtensions та isExtensible для запобігання додаванню нових властивостей до об'єкта та перевірки стану об'єкта відповідно.
 * obj - вхідний об'єкт.
 * Повертає - булеве значення, що вказує, чи можна додати нові властивості до об'єкта.
 */
function sumAndPrint(arr) {
  if (!Array.isArray(arr)) {
    return "Not an array";
  }

  arr.forEach((element) => console.log(element));

  return arr.reduce((summ, element) => (summ += element));
  // Перевіряємо, чи вхідний параметр є масивом, якщо ні повертаємо 'Вхідний параметр має бути масивом'
  // За допомогою методу reduce() обчислюємо суму елементів масиву.
  // За допомогою методу forEach() виводимо кожен елемент масиву в консоль.
  // Повертаємо суму елементів масиву.
}
console.log("Завдання: 8 ==============================");
console.log(checkAndPreventExtensions({ a: 1, b: 2 })); // Виведе false

// Завдання: 9

/**
 * Функція sealAndCheck приймає об'єкт.
 * Функція запечатовує об'єкт, а потім перевіряє, чи запечатаний об'єкт.
 * Використовуються методи seal та isSealed для запечатування об'єкта та перевірки стану об'єкта відповідно.
 * obj - вхідний об'єкт.
 * Повертає - булеве значення, що вказує, чи запечатаний об'єкт.
 */
function flattenSquareAndFilter(arr, threshold) {
  if (!Array.isArray(arr)) {
    return "Not an array";
  }

  return arr
    .flat()
    .map((element) => element * element)
    .filter((element) => element > threshold);
  // Перевіряємо, чи вхідний параметр є масивом, якщо ні повертаємо 'Вхідний параметр має бути масивом'
  // За допомогою методу flat() вирівнюємо масив.
  // За допомогою методу map() підносимо кожен елемент масиву до квадрату.
  // За допомогою методу filter() фільтруємо елементи, які більше за порогове значення.
  // Повертаємо вирівняний масив, елементи якого підняті до квадрату і профільтровані.
}
console.log("Завдання: 9 ==============================");
console.log(sealAndCheck({ a: 1, b: 2 })); // Виведе true

// Завдання: 10

/**
 * Функція `getLastElementsSumAndPrint` обчислює суму останніх n елементів масиву і виводить їх в консоль.
 * Використовується методи `reduceRight()`, `slice()` і `forEach()` для реалізації.
 *  arr - вхідний масив.
 *  n - кількість останніх елементів, які необхідно взяти до уваги.
 * Повертає - sum - сума останніх n елементів масиву.
 */
function getLastElementsSumAndPrint(arr, n) {
  if (!Array.isArray(arr)) {
    return "Not an array";
  }

  const lastNElements = arr.slice(-n);
  const sum = lastNElements.reduce(
    (accumulator, element) => accumulator + element,
    0
  );

  lastNElements.forEach((element) => console.log(element));

  return sum;
}
// Перевіряємо, чи вхідний параметр є масивом, якщо ні повертаємо 'Вхідний параметр має бути масивом'
// За допомогою методу slice() вибираємо останні n елементів масиву.
// За допомогою методу reduceRight() обчислюємо суму останніх n елементів масиву.
// За допомогою методу forEach() виводимо кожен елемент з останніх n в консоль.
// Повертаємо суму останніх n елементів масиву.

console.log("Завдання: 10  ==============================");
console.log(getLastElementsSumAndPrint([1, 2, 3, 4, 5], 2)); // Виведе
// 4
// 5
// 9

// Завдання: 11

/**
 * Функція getObjectValuesSum приймає об'єкт, в якому значення є числами, і повертає суму всіх значень.
 * Використовується метод Object.values() для отримання всіх значень об'єкта, а потім метод reduce() для обчислення суми значень.
 *
 *  obj - Об'єкт, для якого потрібно обчислити суму значень.
 * Повертаємо - Сума всіх значень об'єкта.
 */
function wordLengths(arr) {
  if (!Array.isArray(arr)) {
    return "Not an array";
  }

  return arr.map((element) => element.length);
  // Перевіряємо, чи вхідний параметр є масивом, якщо ні, повертаємо 'Вхідний параметр має бути масивом'
  // Використовуємо метод map для створення нового масиву, де кожний елемент - це довжина відповідного слова з вхідного масиву
  // Повертаємо новий масив
}

console.log("Завдання: 11 ==============================");
console.log(getObjectValuesSum({ a: 1, b: 2, c: 3 })); // Виведе 6

// Завдання: 12

/**
 * Функція convertArrayToObj приймає масив масивів, де кожний підмасив має два елементи - ключ та значення.
 * Функція перетворює масив у об'єкт за допомогою методу Object.fromEntries().
 * Якщо у масиві є дубльовані ключі, функція видасть повідомлення про це.
 *
 *  arr - Масив масивів, де кожний підмасив має два елементи - ключ та значення.
 * Повертаємо - Об'єкт, створений з масиву.
 */
function insertElementAt(arr, index, element) {
  if (!Array.isArray(arr)) {
    return "Not an array";
  }

  arr.splice(index, 0, element);

  return arr;
  // Перевіряємо, чи вхідний параметр є масивом, якщо ні повертаємо 'Вхідний параметр має бути масивом'
  // Використовуємо метод splice для вставки елемента на позицію index
  // Повертаємо масив з вставленим елементом
}

console.log("Завдання: 12 ==============================");
const arr = [
  ["a", 1],
  ["b", 2],
  ["c", 3],
  ["a", 4],
];
console.log(convertArrayToObj(arr)); // Виведе {a: 4, b: 2, c: 3}
